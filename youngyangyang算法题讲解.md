# youngyangyang算法题讲解



## 一、数组

**数组是存放在连续内存空间上的相同类型数据的集合**

c++/c的二维数组在内存上是连续存储的，java不是，可能外层那一维（n[i] [j]中的i）是连续的，然后外层的各个元素存着到内层那一维的地址（每个i对应的那一堆j），每个i的那一堆j是连续的，但不同i的j是不连续的。

#### 二分查找

注意区间的开闭以及每次查找时left是否能够等于right，我选择**左闭右闭区间**，那么每次查找时**left≤right**

middle的下标值取(left+right)/2或(left+right+1)/2都可以，我选择前者。

#### 移除元素

双指针法



## 二、链表

数组在内存中连续分布，链表在内存中不是连续分布。链表通过指针域的指针链接在内存中各个节点。

#### 203.删除链表元素

注意在前面添加一个虚拟头节点dummy更方便

#### 206.反转链表

**经典题目！**注意有递归和非递归两种做法

#### 24.两两交换链表中的节点

注意还是要用到虚拟头节点dummy（用来作为现在正在交换的两个节点的前一个结点）

#### 19.删除链表的倒数第N个节点

快慢指针，注意也要用虚拟头节点dummy

#### 160.求链表的相交节点

比较容易想到的方法是先比较两个链表的长度差，然后让它们两个尾部对齐，从同样开始部位开始往后遍历。

另一种代码量少但难想到的方法是双指针法：让p1从headA开始，p2从headB开始，二者同时往后遍历，当p1==null时,p1=headB，当p2==null时,p2=headA，直到找到p1==p2的节点。这种做法利用的其实也是长度差：假设两个链表重合部分长度为c，A前面的部分长a，B前面的部分长b，那有a+c+b+1=b+c+a+1（加多的那个1是加上了后面的null，这个必须要加，因为若两个链表没有相交部分，最后p1 p2是在同时等于null的时候相遇，也就是c=0的情况），也就是假如两个链表有重合的部分，两个指针走相同长度之后一定会相遇。

#### 142.环形链表

和上一题类似，也用到了链表长度的巧思。

- 设入环之前长度为a，环长度为b

- 设置两个快慢指针fast和slow，两者一起从head往后走，fast每走2格slow走一格，如果fast经过了null则说明没有环，返回null
- 如果有环的话两者会在环里相遇，设fast和slow各走了f、s，则f=2s，又因为fast比slow多走的那一部分其实就是在环里转，所以f=s+nb，所以2s=s+nb=>s=nb
- 又因为每个节点从头开始都是往后走a+nb就到环的入口结点，所以让slow再走a即可
- 重新设一个新指针p指向head，和slow一起往前走，走a步的时候肯定会在环的入口节点处相遇



## 三、哈希表

java中的hashmap：数组+链表，还有扩容等操作。

哈希表的核心思想是**可以根据一个索引来获得某个值，即查询的时间复杂度为O(1)**，所以按这个思想来看**数组也可以被当成一个简单的哈希表（索引是数组下标）**。

 

- 需要注意第454题和第15、18题的区别，第454题的要求是不同三元组的【下标不同就可以，元素可以相同】而第15、8题均要求不同三元组的【元素也不可以相同（注意是组间元素不能同，每个元素内元素可以同）】，所以第15、18题不适合用hash，用双指针比较好。（以此类推，要求元素不能相同的五数之和、六数之和……用的也是双指针法）



## 四、字符串

#### 344.反转字符串

双指针法，先让p1=0,p2=s.length-1，p1和p2的元素互换，然后p1++，p2--，直到两者相遇

#### 541.反转字符串Ⅱ

和上面思路一样，也是每次弄一个翻转区间，然后每一轮翻转区间往前走2k就可以了

#### 剑指Offer05.替换空格

可以用StringBuilder逐个添加字符串段，也可以用双指针法（不过注意要从后往前）

#### 28.找出字符串中第一个匹配项的下标

**KMP算法——用来解决字符串匹配问题**

前缀表：用于找到之前匹配过的内容

- 前缀：一定包含首字母，不包含尾字母的所有子串
- 后缀：一定包含尾字母，不包含首字母的所有字串
- 前缀表存的就是字符串每一位的最长相等前后缀（前缀表用一个叫next的int[]数组来存）
- 当模式串下标为i的字符不匹配了的时候，不是又从头开始匹配，而是得到前缀表里下标为i-1的字符对应的最长相等前后缀n，从模式串下标为n的字符开始匹配



## 贪心算法

- 本质：每一阶段选局部最优，从而达到全局最优
- 什么时候用：感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。
- 步骤：将问题分解为子问题，求解子问题的局部最优，从而得到全局最优
- 贪心和动态规划的区别：动态规划一定和前一个阶段有关，贪心无关

## 动态规划

- 动规五部曲

  1.确定dp数组（dp table）以及下标的含义

  2.确定递推公式

  3.dp数组如何初始化

  4.确定遍历顺序

  5.举例推导dp数组

## 动态规划中的背包问题

01背包：每个物品数量只有一个，选或不选

完全背包：每个物品数量有无数个，可以不选或选若干个

##### 01背包的二维数组dp[i] [j]含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少

dp[i] [j]中，i的个数是物品的个数，j是从0到背包最大容量

推导dp[i] [j]的方法——放或不放物品i：

- 当weight[i]>j时：不放，dp[i] [j]=dp[i-1] [j]

- 当weight[i]≤j时：放，dp[i] [j]=dp[i - 1] [j - weight[i]] + value[i]

- 综上：

  weight[i]>j时，dp[i] [j]=dp[i-1] [j]；

  weight[i]≤j时，dp[i] [j]=max(dp[i-1] [j], dp[i - 1] [j - weight[i]] + value[i])

初始化：

- j=0时：dp[i] [0]=0
- i=0时：当j<weight[0]时，dp[0] [j]=0；j≥weight[0]时，dp[0] [j]=value[0]

遍历顺序：

- 嵌套两个遍历，for i里包着for j也行，**反过来也行**

返回结果：当有m个物品，背包容量为n时，返回**dp[m] [n]**

##### 01背包问题也可以把二维数组降为一维滚动数组

因为从上面可知，i这一层只和i-1这一层有关，且dp[i-1] [j]和dp[i - 1] [j - weight[i]]一定是在dp[i] [j]左上方的，所以其实可以把i这一层去掉，只留下j这一层

weight[i]>j时，dp[j]=dp[j]；

weight[i]≤j时，dp[i] [j]=max(dp[j], dp[j - weight[i]] + value[i])

初始化：全为0（或者和二维数组的版本那样初始化，不同的是下面遍历时i要从1开始遍历）

遍历顺序：

也是一个嵌套循环，i套着j（不能反），i是遍历物品，如果初始化时dp全为0则从i=0开始，如果和二维数组那样初始化那从i=1开始，j是遍历背包，**需要注意的是j要从最大容量开始倒序遍历（因为算右边的数时需要用到左边的数，如果先算左边的数，那左边的数就会被i层的值覆盖了，就不是原来i-1层的值了；而算左边的数不会用到右边的数，所以右边的数先被改也没有什么影响）**