# youngyangyang算法题讲解



## 一、数组

**数组是存放在连续内存空间上的相同类型数据的集合**

c++/c的二维数组在内存上是连续存储的，java不是，可能外层那一维（n[i] [j]中的i）是连续的，然后外层的各个元素存着到内层那一维的地址（每个i对应的那一堆j），每个i的那一堆j是连续的，但不同i的j是不连续的。

#### 二分查找

注意区间的开闭以及每次查找时left是否能够等于right，我选择**左闭右闭区间**，那么每次查找时**left≤right**

middle的下标值取(left+right)/2或(left+right+1)/2都可以，我选择前者。

#### 移除元素

双指针法



## 二、链表

数组在内存中连续分布，链表在内存中不是连续分布。链表通过指针域的指针链接在内存中各个节点。

#### 203.删除链表元素

注意在前面添加一个虚拟头节点dummy更方便

#### 206.反转链表

**经典题目！**注意有递归和非递归两种做法

#### 24.两两交换链表中的节点

注意还是要用到虚拟头节点dummy（用来作为现在正在交换的两个节点的前一个结点）

#### 19.删除链表的倒数第N个节点

快慢指针，注意也要用虚拟头节点dummy

#### 160.求链表的相交节点

比较容易想到的方法是先比较两个链表的长度差，然后让它们两个尾部对齐，从同样开始部位开始往后遍历。

另一种代码量少但难想到的方法是双指针法：让p1从headA开始，p2从headB开始，二者同时往后遍历，当p1==null时,p1=headB，当p2==null时,p2=headA，直到找到p1==p2的节点。这种做法利用的其实也是长度差：假设两个链表重合部分长度为c，A前面的部分长a，B前面的部分长b，那有a+c+b+1=b+c+a+1（加多的那个1是加上了后面的null，这个必须要加，因为若两个链表没有相交部分，最后p1 p2是在同时等于null的时候相遇，也就是c=0的情况），也就是假如两个链表有重合的部分，两个指针走相同长度之后一定会相遇。

#### 142.环形链表

和上一题类似，也用到了链表长度的巧思。

- 设入环之前长度为a，环长度为b

- 设置两个快慢指针fast和slow，两者一起从head往后走，fast每走2格slow走一格，如果fast经过了null则说明没有环，返回null
- 如果有环的话两者会在环里相遇，设fast和slow各走了f、s，则f=2s，又因为fast比slow多走的那一部分其实就是在环里转，所以f=s+nb，所以2s=s+nb=>s=nb
- 又因为每个节点从头开始都是往后走a+nb就到环的入口结点，所以让slow再走a即可
- 重新设一个新指针p指向head，和slow一起往前走，走a步的时候肯定会在环的入口节点处相遇



## 三、哈希表

java中的hashmap：数组+链表，还有扩容等操作。

哈希表的核心思想是**可以根据一个索引来获得某个值，即查询的时间复杂度为O(1)**，所以按这个思想来看**数组也可以被当成一个简单的哈希表（索引是数组下标）**。

 

- 需要注意第454题和第15、18题的区别，第454题的要求是不同三元组的【下标不同就可以，元素可以相同】而第15、8题均要求不同三元组的【元素也不可以相同（注意是组间元素不能同，每个元素内元素可以同）】，所以第15、18题不适合用hash，用双指针比较好。（以此类推，要求元素不能相同的五数之和、六数之和……用的也是双指针法）



## 四、字符串

#### 344.反转字符串

双指针法，先让p1=0,p2=s.length-1，p1和p2的元素互换，然后p1++，p2--，直到两者相遇

#### 541.反转字符串Ⅱ

和上面思路一样，也是每次弄一个翻转区间，然后每一轮翻转区间往前走2k就可以了

#### 剑指Offer05.替换空格

可以用StringBuilder逐个添加字符串段，也可以用双指针法（不过注意要从后往前）

#### 28.找出字符串中第一个匹配项的下标

**KMP算法——用来解决字符串匹配问题**

前缀表：用于找到之前匹配过的内容

- 前缀：一定包含首字母，不包含尾字母的所有子串
- 后缀：一定包含尾字母，不包含首字母的所有字串
- 前缀表存的就是字符串每一位的最长相等前后缀（前缀表用一个叫next的int[]数组来存）
- 当模式串下标为i的字符不匹配了的时候，不是又从头开始匹配，而是得到前缀表里下标为i-1的字符对应的最长相等前后缀n，从模式串下标为n的字符开始匹配



## 贪心算法

- 本质：每一阶段选局部最优，从而达到全局最优
- 什么时候用：感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。
- 步骤：将问题分解为子问题，求解子问题的局部最优，从而得到全局最优
- 贪心和动态规划的区别：动态规划一定和前一个阶段有关，贪心无关

#### 455.分发饼干

为了不造成饼干尺寸的浪费，那就要尽量把大尺寸的饼干分给大胃口的孩子

把饼干和孩子胃口都增序排序后，从后向前遍历饼干：

局部最优：每次尽量使大饼干分给大胃口的孩子

全局最优：所有饼干都分给了它所能满足的最大胃口的孩子，没有饼干被浪费

（作者网站写的也对，按我下面这样写也对，我下面这样其实更好理解）

```java
public int findContentChildren(int[] g, int[] s) {//g是胃口，s是饼干尺寸
        /**
         * 全局最优：每个饼干都分给了它所能满足的最大胃口的孩子，没有饼干被浪费
         * 局部最优：从后往前遍历饼干，把它分给它所能满足的最大胃口的孩子
         */
        Arrays.sort(g);
        Arrays.sort(s);
        int res=0;
        int index=g.length-1;
        for(int i=s.length-1;i>=0;i--){
            int size=s[i];
            //从后往前找到该饼干所能满足的最大胃口的孩子
            while(index>=0){
                if(g[index]<=size){
                    res++;
                    index--;
                    break;
                }
                index--;
            }
        }
        return res;
    }
```

#### 376. 摆动序列

局部最优：每次取局部极值（即峰值）

需要考虑平坡以及首尾两个元素的特殊情况

#### 53.最大子序列和

贪心思想：遍历整个数组，如果前面的连续和是负数，那立刻抛弃前面的从现在这个数开始

动态规划：dp[i]=max(dp[i-1]+nums[i], nums[i])，然后记录下max

#### 122.买卖股票的最佳时机

这里需要注意的是，当天是可以先把股票卖了再买入这个股票的，所以只要第i天比第i-1天大就把nums[i]-nums[i-1]加进去就可以了

#### 055.跳跃游戏

贪心思想：每次取最大能到达的范围cover,然后一直在cover这个范围之内往前走，看是否能覆盖最后一个点

#### <font color="red">045.跳跃游戏Ⅱ</font>

要求跳的次数最少

贪心思想：每次若能到的最远距离是nextCover，则看这个nextCover是否覆盖了最后一个元素，如果覆盖了那就可以结束了，如果不能覆盖那说明肯定还要多走一次到nextCover范围内的某个元素处，走到这个元素了后又重复之前的判断……

#### 860.柠檬水找零

当放入5和10的时候其实操作都是固定的，只有放入20的时候有找一张10和一张5或者找三张5的情况

局部最优：当放入20的时候优先找一张10+一张5，因为5可以用来在放入10的时候找5，更“万能”

#### 135.分发糖果

注意：这里是说相邻情况如果a>b，那么a分得的糖果一定要比b多，如果a=b，那么其实是可以随便的

贪心思想：分两次遍历！第一次考虑右边比左边大的情况，第二次考虑左边比右边大的情况，不能一次考虑两边，否则会顾此失彼！

第一次从左往右，下标0的默认分得1，若下标i的大于i-1的，那么i分得的比i-1多1个；否则分1个

第二次从右往左，下标len-1的不动，若下标i的大于i+1的，那么i分得的个数=max(i在上一次分得的个数，i+1分得的个数)，以保证它如果比左右两边的都大，那它分得的比左右两边都多；否则还是按它上次分到的

#### 406.根据身高重建队列

这道题和135.分发糖果类似，都是先按一个条件排之后，再按第二个条件排，如果一次同时考虑两个条件那就会顾此失彼

这道题先考虑h，先把所有数按照从大到小排（身高相同的k小的站前面），

再从左往右遍历，考虑k，把这个数组往ki的位置插

这道题需要注意的一个点是重写Arrays.sort函数里Comparator接口的compare方法，而且是二维数组的compare

#### 435.无重叠区间【二维数组重叠区间问题】

选择按左边界排序，不管右边界

排序之后遍历排序后的二维数组，用一个preEnd记录之前最左端的右边界

如果nums [i] [0]≥end，那肯定没有重叠，否则肯定重叠了preEnd更改为nums [i] [1]，这时候选择删除右边界最大的那个（贪心思想：为了尽可能少地影响后面的数），所以preEnd改为preEnd和nums [i] [1]中较小的一个

#### 56.合并区间【二维数组重叠区间问题】

和上一题思路类似，把二维数组按左边界排序，然后遍历排序后的二维数组

维护一个start和一个end，如果nums [i] [0]>end则说明start和end要从新的开始了，把之前的[start,end]加入结果中，否则说明肯定该区间和之前的存在重合，令end=max(end,nums[i] [1])



## 动态规划

- 动规五部曲

  1.确定dp数组（dp table）以及下标的含义

  2.确定递推公式

  3.dp数组如何初始化

  4.确定遍历顺序

  5.举例推导dp数组

## 动态规划中的背包问题

01背包：每个物品数量只有一个，选或不选

完全背包：每个物品数量有无数个，可以不选或选若干个

##### 01背包的二维数组dp[i] [j]含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少

dp[i] [j]中，i的个数是物品的对应下标，j是从0到背包最大容量

推导dp[i] [j]的方法——放或不放物品i：

- 当weight[i]>j时：不放，dp[i] [j]=dp[i-1] [j]

- 当weight[i]≤j时：放，dp[i] [j]=dp[i - 1] [j - weight[i]] + value[i]

- 综上：

  weight[i]>j时，dp[i] [j]=dp[i-1] [j]；

  weight[i]≤j时，dp[i] [j]=max(dp[i-1] [j], dp[i - 1] [j - weight[i]] + value[i])

初始化：

- j=0时：dp[i] [0]=0
- i=0时：当j<weight[0]时，dp[0] [j]=0；j≥weight[0]时，dp[0] [j]=value[0]

遍历顺序：

- 嵌套两个遍历，for i里包着for j也行，**反过来也行**

返回结果：当有m个物品，背包容量为n时，返回**dp[m] [n]**

##### 01背包问题也可以把二维数组降为一维滚动数组

因为从上面可知，i这一层只和i-1这一层有关，且dp[i-1] [j]和dp[i - 1] [j - weight[i]]一定是在dp[i] [j]左上方的，所以其实可以把i这一层去掉，只留下j这一层

weight[i]>j时，dp[j]=dp[j]；

weight[i]≤j时，dp[i] [j]=max(dp[j], dp[j - weight[i]] + value[i])

初始化：全为0（或者和二维数组的版本那样初始化，不同的是下面遍历时i要从1开始遍历）

遍历顺序：

也是一个嵌套循环，i套着j（不能反），i是遍历物品，如果初始化时dp全为0则从i=0开始，如果和二维数组那样初始化那从i=1开始，j是遍历背包，**需要注意的是j要从最大容量开始倒序遍历（因为算右边的数时需要用到左边的数，如果先算左边的数，那左边的数就会被i层的值覆盖了，就不是原来i-1层的值了；而算左边的数不会用到右边的数，所以右边的数先被改也没有什么影响）**

#### 416.分割等和子集【给定背包容量，求能不能装满背包】

可以化为01背包问题——背包体积为sum/2，问能不能放入若干个数使得背包刚好放满

- dp的含义：dp[i] [j]表示遍历到下标为i的数时将下标为0-i的数放入容量为j的背包时背包的最大重量
- 初始化：i=0时，若j大于等于nums[0]，则dp [i] [j]=nums[0]，否则dp [i] [j]=0；j=0时，dp [i] [j]=0
- 遍历顺序：i嵌套着j，两个都是从左到右
- 返回：当j=target时，若有某i使得dp [i] [target]==target，则返回true

#### 1049.最后一块石头的重量【给定背包容量，尽可能装满，能装多满】

可以转为背包问题，就是尽量把所有石头划为重量相等的两堆

即求出背包最大容量target=sum/2时背包重量的最大值，

因为sum/2是向下取整，所以这个最大值一定小于另一堆

所以结果是sum-dp[stones.length-1] [target]-dp[stones.length-1] [target]

#### <font color="red">494.目标和(这道题建议死记硬背，佛了……）</font>【给定背包容量，装满背包有多少种方法】

这道题漏说了一个条件：数组中的数一定是非负数！

这道题设前面+号的数之和为x，-号的数之和为y，x-y=target, x+y=sum  =>x=(target+sum)/2

注意：当(target+sum)不能整除2以及target的绝对值比sum要大的时候肯定是不能满足的（因为nums[i]都是非负数）

所以就转化为背包问题，就有没有和为x=(target+sum)/2的情况，并且要求有多少种满足这种情况的<font color="red">**组合**（注意不是求最大重量了，而是求组合数！）</font>

- dp[j]：从数组中取数一共有多少种方法使得取得的数之和为j

- 初始化：<font color="red">dp[0]=1</font>

- 当有一个nums[i]时，dp[j]=dp[j]+dp[j-nums[i]]，原因：

  ![image-20230405221338055](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230405221338055.png)

- 代码如下：

  ```java
  public int findTargetSumWays(int[] nums, int target) {
          int sum = 0;
          for (int n : nums) {
              sum += n;
          }
          if ((target + sum) % 2 != 0) {
              return 0;
          }
          if (Math.abs(target) > sum) {
              return 0;
          }
          int x = (target + sum) / 2;
  
          int[] dp = new int[x + 1];
          dp[0] = 1;
          for (int i = 0; i < nums.length; i++) {
              for (int j = x; j >= nums[i]; j--) {
                  dp[j] += dp[j - nums[i]];
              }
          }
          return dp[x];
      }
  ```

#### 474.一和零【给定背包容量，装满背包最多有多少个物品】



## 打家劫舍

打家劫舍问题的要点在于dp[i]表示的是<font color="red">0-i这一段可以偷的最大金额，而不是说i这个房间一定要被偷</font>

#### 198.打家劫舍1

- dp[i]表示<font color="red">考虑下标0-i的房屋最多</font>可以偷窃的金额
- 当走到i时，有两种情况，偷或不偷，如果偷，则dp[i] = dp[i - 2] + nums[i]，如果不偷则dp[i]=dp[i-1]，取两者中大的
- 返回dp最后一个数

#### 213.打家劫舍Ⅱ

这题的难点在于成环了，其实特殊的点在于首尾元素，当考虑首部元素时，一定不能考虑尾部元素，当考虑尾部元素时，一定不能考虑首部元素

所以其实得遍历两次，第一次是从下标0到len-2，也就是首部元素到倒数第二个元素；第二次是从下标1到len-1，也就是第二个元素开始到尾部元素

取两次遍历的结果中的最大值即可

![](https://camo.githubusercontent.com/7b9cd836f98b01ea8a146920e53015d909783ef8c4ceb066657e2f90f00915bf/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303832313337342d32303233303331303133343030333936312e6a7067)

![](https://camo.githubusercontent.com/3a5cfd80c966a0c512d8b4b57c51403b8982c7a4be89e5e994fb08d17fa19c94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303834323439312d32303233303331303133343030383133332e6a7067)

注意打家劫舍问题中dp[i]是考虑是否放这个元素的意思，不是一定要放这个元素的意思，如果没有遍历到i那么说明这个元素不需要被考虑

#### 337.打家劫舍Ⅲ

<font color="red">树形</font>打家劫舍

在动规的思想上融合DFS+后序遍历，当遍历到每个节点时先遍历其两个子节点，分别得到fl（取左子节点）、gl（不取左子节点）、fr（取右子节点）、gr（不取右子节点）四个数，然后如果取这个节点的话那就是val+gl+gr，不取的话就是val+max(fl,gl)+max(fr,gl)，返回这两个值到上一步递归，最后返回的是根节点对应的那两个值，取最大的即可。

<font color="voilet">建议可以看一下我之前写的代码</font>





## 股票问题





## 动态规划中的字符串操作问题

#### 字符串最小编辑距离

给两个字符串A、B，每次可以插入/删除或修改一个字符，求经过多少次字符操作能够使两字符串变为相同

**edit\[i][j]**表示以下标i-1为结尾的字符串A和以下标j-1为结尾的字符串B的最小编辑距离

确定递推公式的过程——当遍历到A[i-1]、B[j-1]时，一共有以下四种情况：

- A[i-1]=B[j-1]：不做任何操作，edit\[i][j]=edit\[i-1][j-1]

- A[i-1]≠B[j-1]：

  - A删除掉下标i-1的元素，那么就是以下标i-2为结尾的A与 下标j-1为结尾的B的最近编辑距离 再加上一个操作：edit\[i][j]=edit\[i-1][j]+1

  - B删除掉下标j-1的元素，那么就是以下标i-1为结尾的A与 下标j-2为结尾的B的最近编辑距离 再加上一个操作：edit\[i][j]=edit\[i][j-1]+1

    <font color="red">【需要注意的是，字符串删除结尾字符其实相当于在另一个字符串结尾添加字符，例如 word1 = “ad” ，word2 = “a”，word1删除元素’d’ 和 word2添加一个元素’d’，变成word1=“a”, word2=“ad”， 最终的操作数是一样的】</font>

  - A替换A\[i-1]为B\[j-1]：edit\[i][j]=edit\[i-1][j-1]+1

  ```java
  if (A[i - 1] == B[j - 1]) {
      edit[i][j] = edit[i - 1][j - 1];
  }
  else {
      edit[i][j] = min({edit[i - 1][j - 1], edit[i - 1][j], edit[i][j - 1]}) + 1;
  }
  ```

初始化：

- `edit[i][0]` ：以下标`i-1`为结尾的字符串`A`，和空字符串`B`，最近编辑距离，为i
- `edit[0][j]` ：以下标`j-1`为结尾的字符串`B`，和空字符串`A`，最近编辑距离，为j

遍历顺序：i中嵌套j，两者都是从1开始到结尾

完整代码：

```java
int minEditDistance(String A,String B){
    int[][] edit=new int[A.length()+1][B.length()+1];
    for(int i=0;i<=A.length();i++){
        edit[i][0]=i;
    }
    for(int j=0;j<=B.length();j++){
        edit[0][j]=j;
    }
    for(int i=1;i<=A.length();i++){
        for(int j=1;j<=B.length();j++){
            if(A.charAt(i)==B.charAt(j)){
                edit[i][j]=edit[i-1][j-1];
            }
            else{
                edit[i][j]=Math.min(edit[i-1][j],Math.min(edit[i][j-1],edit[i-1][j-1]))+1;
            }
        }
    }
    return edit[A.length()][B.length()];
}
```

