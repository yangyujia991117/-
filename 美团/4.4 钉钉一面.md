# 4.4 钉钉一面

### hashmap put操作

答出来了



### hashmap为什么要用红黑树、红黑树的结构

**红黑树特点** :

1. 每个节点非红即黑；
2. <font color="red">根节点总是黑色的</font>；
3. <font color="red">每个叶子节点都是黑色的空节点（NIL节点）</font>；
4. 如果节点是<font color="red">红色</font>的，则它的子节点必须是<font color="red">黑色</font>的（反之不一定），也就是说<font color="red">从叶子到根的路径不能有连续两个红色节点</font>；
5. 从任一个节点到它的每个叶节点的每条路径，必须包含<font color="red">相同数目的黑色节点（即相同的黑色高度）</font>；
6. 新插入的节点是<font color="red">红色节点</font>，后续可以通过变色变为黑色

**红黑树好处：**

是**<font color="red">自平衡的二叉查找树</font>**，正是由于红黑树的种种规定，使得红黑树<font color="red">从根到叶子的最长路径不会超过最短路径的2倍</font>，在hashmap中可以<font color="red">**提高查询效率**</font>

当插入或删除节点时，为了保证以上规则，红黑树需要进行一些调整：变色、左旋转、右旋转

**红黑树的应用** ：TreeMap（自排序的map）、TreeSet（自排序的set）、JDK1.8的HashMap。



### 用一个数据结构实现LRU（最近最少使用算法）缓存

LRU缓存：删除的是最久未使用的数据

一个数组存元素，一个数组存对应下标元素的最近一次使用时间

#### 基于hashmap+双向链表实现LRU

双向链表的每个Node有四个属性：

- key：每个节点进入的时候都是以<font color="blue">(key,value)</font>的形式进入的，Node的key和value对应的就是这两个
- value：
- prev：前一个Node
- next：后一个Node

每次使用数据，或者插入新数据的时候，我们把它移动到头部（可分为删除该节点及在双向链表头部添加节点这两步操作），这样尾部节点就是下一次要替换的那个节点。

hashmap用于快速查找，hashmap的key为节点的key，value为对应Node。

##### get操作

首先利用hashmap判断key是否存在，不存在就返回-1，存在则 key 对应的节点是最近被使用的节点，通过哈希表定位到该节点，并将其移动到双向链表的头部，最后返回该节点的值。

##### put <key,value>操作

利用hashmap判断key是否存在，如果存在则覆盖对应节点的value，不存在则执行以下操作：

创建一个新Node，添加进hashmap，然后将该Node添加进双向链表的头部，如果此时链表长度超出容量，则删除最尾部的节点。

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```



### CurrentHashmap如何保证线程安全？get的时候是否加锁？

JDK1.8前：segment分段机制，JDK1.8后：取消了分段，只对那一个桶进行加锁，加锁用CAS+synchronized

#### CurrentHashmap的结构

##### JDK1.8之前的

![](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

有一个Segment数组，这个segment数组类似一个hashmap，每个元素都是一个HashEntry数组的入口，HashEntry可以进行扩容。但`Segment` 的个数一旦**初始化就不能改变**，默认 `Segment` 的个数是 16 个，也可以认为 `ConcurrentHashMap` 默认支持最多 16 个线程并发。

##### JDK1.8及其之后的

![](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 **Segment 数组 + HashEntry 数组 + 链表**，而是 **Node 数组 + 链表 / 红黑树**。当冲突链表达到一定长度时，链表会转换成红黑树。





### 最熟悉哪个排序算法？介绍一下它的过程，并说一下它的时间复杂度

 过程不再赘述。

<font color="red">最差**n^2**，最好nlogn，平均nlogn，取决于所选择的基准值</font>

最坏情况：<font color="red">总是以第一个元素作为基准值，且要处理的数组有序，</font>这个时候递归调用的两个子数组中左边那个总是为空，这时候一共要递归n次（两个子数组算一层，一层一个递归）

平均情况：<font color="red">总是将中间元素作为基准值，</font>这时候只用递归logn次

每一次递归都要遍历n个元素（每一层虽然被分在很多个函数中排序，但是加起来都是那么多个元素）

所以最坏情况n^2，最好情况nlogn，平均也是nlogn，因为平均就是取到中间那个位置



### synchronized的实现机制？



### synchronized的锁升级？



### 在浏览器输入一个url到服务端返回内容的过程

1.DNS解析（



### spring bean的生命周期

### Spring MVC如何获得前端http传来的参数



### 线程池的阻塞队列如何实现

