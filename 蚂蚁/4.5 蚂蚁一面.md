# 4.5 蚂蚁一面

## 八股部分

### 非关系型数据库和关系型数据库的区别

![image-20230412130758193](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230412130758193.png)

### 缓存穿透、缓存击穿、缓存雪崩及其应对策略

#### 缓存穿透

大量请求的key是不合理的，<font color="red">根本不存在于缓存中也不存在于数据库中</font>，(例如黑客伪造的假key）导致请求直接到了数据库，没有经过缓存这一层，对数据库造成了巨大压力。

解决方法：

- 缓存无效key：如果缓存和数据库中都查不到某个key那么就将这个key存到redis缓存中并设置一个较短的过期时间。缺点：会导致redis中存着大量的无效key
- 布隆过滤器：在缓存之前加一个布隆过滤器，把所有有效的key存在该布隆过滤器中，有请求过来时通过过滤器判断是否是有效key，如果无效的话直接返回错误。缺点：布隆过滤器<font color="red">**可能会将没有的元素判为有，但反过来不会**</font>（原因是布隆过滤器由一个位数组+若干个hash函数组成，当加入一个key时会通过这些hash函数计算出若干个hash值然后将位数组的对应位置为1，当判断一个key在不在布隆过滤器中时也会进行同样的hash计算，然后根据位数组对应的位是否全为1来判断那个key在不在里面，这时候不同的key可能会计算出同样的hash值，所以会存在误判）

#### 缓存击穿

当大量请求某一个key（**热点数据**），但该key<font color="red">存在于数据库中但不存在于缓存中（可能是因为过期了）</font>，导致大量瞬时请求直接打在数据库上。

解决方法：

- 设置热点数据永不过期或者过期时间比较长。

- 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。

- 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

#### 缓存雪崩

缓存<font color="red">在同一时间大面积的失效</font>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力

<font color="red">缓存服务宕机</font>也会导致缓存雪崩

解决办法：

- 针对缓存服务宕机的情况：
  - 采用redis集群，避免因为单机出现问题导致整个缓存服务不可用
  - 限流，避免同时处理大量请求

- 针对热点缓存失效的情况：
  - 设置不同的失效时间比如随机设置缓存的失效时间。
  - 缓存永不失效（不太推荐，实用性太差）。
  - 设置二级缓存。

### 公平锁和非公平锁

**公平锁** : 锁被释放之后，<font color="red">先申请的线程先得到锁</font>。性能较差一些，因为公平锁为了<font color="red">保证时间上的绝对顺序，上下文切换更频繁</font>。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

**非公平锁** ：锁被释放之后，<font color="red">后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的</font>。性能更好，但<font color="red">可能会导致某些线程永远无法获取到锁</font>。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。



### 悲观锁和乐观锁

#### 悲观锁

总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以<font color="red">每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放</font>。

**例子：**synchronized、ReentrantLock等独占锁

#### 乐观锁

总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。

##### 实现方式：

- 版本号机制：每一次更新就更新一下版本号，当要提交事务时判断该版本号是否与预期的相同

- CAS算法

  - 对应类：`sun.misc`包下的`Unsafe`类提供了`compareAndSwapObject`、`compareAndSwapInt`、`compareAndSwapLong`方法来实现的对`Object`、`int`、`long`类型的 CAS 操作

  - 涉及三个数：要更新的变量值、预期值、拟写入的新值

  - 可能存在问题：**ABA问题**——如果检查到要更新的变量值=预期值，也不能说明这个变量没有被修改过，因为它可能被改为了其他值，然后又改回来了

    解决办法：在变量前面追加上**版本号**或者**时间戳**，在检查的时候不仅检查要更新的变量值是否=预期值，还要检查版本号和时间戳是否与预期值相等。

    对应源码：JDK 1.5 以后的 `AtomicStampedReference` 类就是用来解决 ABA 问题的，其中的 `compareAndSet()` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

    

### 分布式锁

可以用redis

### 用什么方式创建新线程

方法1：实现Runnable接口，重写run方法，实例化该类的一个对象a后作为参数构建一个Thread对象：Thread thread=new Thread(a)，然后thread.start()

方法2：继承Thread类，重新run方法，然后直接实例化该类的一个对象a，调用a.start()





## 手撕算法：

一个从1-n的数组，求所有连续和为n的子数组
如n=6时：1+2+3、6
n=15时：1+2+3+4+5、7+8、15

```java
public static List<int[]> cal(int n){
        int[] nums=new int[n];
        for(int i=0;i<n;i++){
            nums[i]=i+1;
        }
        List<int[]> res=new ArrayList<>();
        int l=0,r=1;
        int sum=nums[0]+nums[1];

        while(l<r){//这里弄成两个的，因为只有一个元素的在最后加进去了
            System.out.println("l:"+l+",r:"+r+",sum:"+sum);
            if(sum==n){
                res.add(Arrays.copyOfRange(nums,l,r+1));
                sum-=nums[l];
                l++;
            }
            else if(sum>n){
                sum-=nums[l];
                l++;
            }
            else{
                r++;
                sum+=nums[r];
            }
        }
        res.add(new int[]{n});
        return res;
    }
```

