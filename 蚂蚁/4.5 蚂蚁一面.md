# 4.5 蚂蚁一面

## 八股部分

### 非关系型数据库和关系型数据库的区别



### 缓存穿透、缓存击穿、缓存雪崩及其应对策略



### 公平锁和非公平锁

**公平锁** : 锁被释放之后，<font color="red">先申请的线程先得到锁</font>。性能较差一些，因为公平锁为了<font color="red">保证时间上的绝对顺序，上下文切换更频繁</font>。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

**非公平锁** ：锁被释放之后，<font color="red">后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的</font>。性能更好，但<font color="red">可能会导致某些线程永远无法获取到锁</font>。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。



### 悲观锁和乐观锁

#### 悲观锁

总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以<font color="red">每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放</font>。

**例子：**synchronized、ReentrantLock等独占锁

#### 乐观锁

总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。

##### 实现方式：

- 版本号机制：每一次更新就更新一下版本号，当要提交事务时判断该版本号是否与预期的相同

- CAS算法

  - 对应类：`sun.misc`包下的`Unsafe`类提供了`compareAndSwapObject`、`compareAndSwapInt`、`compareAndSwapLong`方法来实现的对`Object`、`int`、`long`类型的 CAS 操作

  - 涉及三个数：要更新的变量值、预期值、拟写入的新值

  - 可能存在问题：**ABA问题**——如果检查到要更新的变量值=预期值，也不能说明这个变量没有被修改过，因为它可能被改为了其他值，然后又改回来了

    解决办法：在变量前面追加上**版本号**或者**时间戳**，在检查的时候不仅检查要更新的变量值是否=预期值，还要检查版本号和时间戳是否与预期值相等。

    对应源码：JDK 1.5 以后的 `AtomicStampedReference` 类就是用来解决 ABA 问题的，其中的 `compareAndSet()` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

    

### 分布式锁

可以用redis

### 用什么方式创建新线程











## 手撕算法：

一个从1-n的数组，求所有连续和为n的子数组
如n=6时：1+2+3、6
n=15时：1+2+3+4+5、7+8、15

```java
public static List<int[]> cal(int n){
        int[] nums=new int[n];
        for(int i=0;i<n;i++){
            nums[i]=i+1;
        }
        List<int[]> res=new ArrayList<>();
        int l=0,r=1;
        int sum=nums[0]+nums[1];

        while(l<r){//这里弄成两个的，因为只有一个元素的在最后加进去了
            System.out.println("l:"+l+",r:"+r+",sum:"+sum);
            if(sum==n){
                res.add(Arrays.copyOfRange(nums,l,r+1));
                sum-=nums[l];
                l++;
            }
            else if(sum>n){
                sum-=nums[l];
                l++;
            }
            else{
                r++;
                sum+=nums[r];
            }
        }
        res.add(new int[]{n});
        return res;
    }
```

